# Rust introduction
## Why Rust
- High Performance
- Reduces mem related errors
- Garbage collection not necessary
- Rust programs require much less memory
- Good for concurrent
- Compiler looks for concurrent errors, not usually found by other compilers
- Rust compiler is robust
- Easy to understand error messages

## Online Book and getting started guide
### Rustup
- This is the rust installer and version managemnet tool
- To update rust:\
`$ rustup update`
- To check the version of rust installed:\
`$ rustc --version`
### Hello world in rust
Create a new rust application using **cargo**, which is the package manager and build system: \
`$ cargo new hello-rust` \
This generates a directory structure:
```
hello-rust
|-Cargo.toml (The manifest file for Rust)
|-src (Source directory)
  |-main.rs (The main file)
```
Include libraries into the current *scope* in  your code using `use` keyword:
```
use std::io;
use rand::Rng;
```
Include rand under [dependencies] in toml:
```
rand = "0.8.5"
```
`println!` is a macro in Rust - anything that ends with an exclamation (!) is a macro in Rust. Functions are prefixed with a `fn` keyword.
### Variables, references and user input
By default, all values in Rust are **immutable**, because Rust wants to help the dev with debugging (tf). `&` before any type name means that it is a reference to a variable. For example, `&mut` means a reference to a mutable object(?).
- To read value from user:
```
let mut name = String::new();
io::stdin().read_line(&mut name).expect("Didn't receive input");
```
- `String::new()` returns an empty string, but not a null-like object - trying to print this does not cause any errors. Does this mean Strings are always concatenated in Rust?

`read_line` returns a `result` which is an enum - has a fixed number of possible values (`Ok` or `Error`).\
Whatever is read in from the keyboard has a newline at the end of it by default, this can be removed by using the `trim_end()` method on the result variable - `name` in this example.
```
let greeting = "Nice to meet you";
println!("Hello {}! {}", name.trim_end(), greeting);
```
To store large numbers, we can separate them by underscores instead of commas.
So, something like `const ONE_MIL: u32 = 1_000_000` is completely valid, and rust takes it as 1000000 only - this is just to make big numbers more readable.\
**Shadowing**: Same variable names can be reused with different types. This is demonstrated below:
```
let age: &str = "47";
let mut age: u32 = age.trim().parse()            // Shadowing; 
        .expect("Age wasn't assigned a number"); // trim to remove whitespaces, parse to convert
```
### Data types
Statically typed: Types are automatically generated by the compiler. Some types are:
- Signed integer: i8, i16, i32, i64, i128, isize (isize and usize depends on the processor- 64 bits on a 64 bit processor)
- Unsigned integer: u8, u16, u32, u64, u128, usize
- Character: char (Single quotes)
- String (Double quotes)

Get maximum possible value for a data-type => `u32::MAX` (like `UINT32_MAX` in C)\
- Precision for f32:6 decimal digits
- Precision for f64: 14 decimal digits

They can also be manually specified using the `<variable_name>:<type>` syntax.
### Generate random numbers
```
let random_num = rand::thread_rng().gen_range(1...101);
println!("Random: {}", random_num);
```
### Conditionals
```
if (a > 10) && (a < 18) {
    // stuff
} else if (age == 21) || (age == 50) {
    // stuff
} else {
    // stuff
}
```
Ternary operator:
```
let can_vote = if my_age >= 18{
    true
} else {
    false
};
```
